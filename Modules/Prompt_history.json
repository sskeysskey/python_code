[
    {
        "id": "2025-05-25 23:43:40",
        "project_name": "fdsafds",
        "project_desc": "fdsafdsa",
        "files": [
            {
                "path": "/Users/yanzhang/Documents/python_code/Append_book.py",
                "filename": "Append_book.py",
                "content": "import os\nimport cv2\nimport time\nimport pyperclip\nimport pyautogui\nimport subprocess\nimport numpy as np\nfrom time import sleep\nfrom PIL import ImageGrab\nimport sys\nsys.path.append('/Users/yanzhang/Documents/python_code/Modules')\nfrom Rename_segment import rename_first_segment_file\n\ndef capture_screen():\n    # 使用PIL的ImageGrab直接截取屏幕\n    screenshot = ImageGrab.grab()\n    # 将截图对象转换为OpenCV格式\n    screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)\n    return screenshot\n\n# 查找图片\ndef find_image_on_screen(template, threshold=0.9):\n    screen = capture_screen()\n    result = cv2.matchTemplate(screen, template, cv2.TM_CCOEFF_NORMED)\n    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\n    # 释放截图和模板图像以节省内存\n    del screen\n    if max_val >= threshold:\n        return max_loc, template.shape\n    else:\n        return None, None\n\ndef get_clipboard_content():\n    content = pyperclip.paste()\n    if not content:\n        return \"\"\n    \n    # 分割成行并去除空白行\n    lines = [line.strip() for line in content.splitlines() if line.strip()]\n    \n    # 如果行数小于3，直接返回原内容\n    if len(lines) < 3:\n        return \"\\n\".join(lines)\n    \n    # 移除第一行和最后一行\n    filtered_lines = lines[:-1]\n    \n    # 重新组合文本\n    return \"\\n\".join(filtered_lines)\n\ndef main():\n    # 定义模板路径字典\n    template_paths = {\n        \"kimi\": \"/Users/yanzhang/Documents/python_code/Resource/Kimi_copy.png\",\n        \"mistral\": \"/Users/yanzhang/Documents/python_code/Resource/Mistral_copy.png\",\n        \"thumb\": \"/Users/yanzhang/Documents/python_code/Resource/poe_thumb.png\",\n        \"success\": \"/Users/yanzhang/Documents/python_code/Resource/poe_copy_success.png\",\n        \"copy\": \"/Users/yanzhang/Documents/python_code/Resource/poe_copy.png\"\n    }\n\n    # 读取所有模板图片，并存储在字典中\n    templates = {}\n    for key, path in template_paths.items():\n        template = cv2.imread(path, cv2.IMREAD_COLOR)\n        if template is None:\n            raise FileNotFoundError(f\"模板图片未能正确读取于路径 {path}\")\n        templates[key] = template\n\n    pyautogui.click(x=1215, y=473)\n    sleep(0.5)\n    pyautogui.scroll(-80)\n    found_copy = False\n    while not found_copy:\n        location, shape = find_image_on_screen(templates[\"mistral\"])\n        if location:\n            print(\"找到copy图了，准备点击copy...\")\n            # 计算中心坐标\n            center_x = (location[0] + shape[1] // 2) // 2\n            center_y = (location[1] + shape[0] // 2) // 2\n            \n            # 鼠标点击中心坐标\n            pyautogui.click(center_x, center_y)\n            found_copy = True\n        else:\n            print(\"没找到图片，继续执行...\")\n            location, shape = find_image_on_screen(templates[\"kimi\"])\n            if location:\n                print(\"找到copy图了，准备点击copy...\")\n                # 计算中心坐标\n                center_x = (location[0] + shape[1] // 2) // 2\n                center_y = (location[1] + shape[0] // 2) // 2\n                \n                modify_x = center_x\n                modify_y = center_y - 2\n\n                # 鼠标点击中心坐标\n                pyautogui.click(modify_x, modify_y)\n                found_copy = True\n            else:\n                location, shape = find_image_on_screen(templates[\"thumb\"])\n                if location:\n                    print(\"找到copy图了，准备点击copy...\")\n                    # 计算中心坐标\n                    center_x = (location[0] + shape[1] // 2) // 2\n                    center_y = (location[1] + shape[0] // 2) // 2\n                    \n                    xCoord = center_x\n                    yCoord = center_y - 50\n\n                    # 使用pyautogui移动鼠标并进行右键点击\n                    pyautogui.moveTo(xCoord, yCoord)\n                    pyautogui.click(button='right')\n                    \n                    sleep(1)\n                    location, shape = find_image_on_screen(templates[\"copy\"])\n                    if location:\n                        # 计算中心坐标\n                        center_x = (location[0] + shape[1] // 2) // 2\n                        center_y = (location[1] + shape[0] // 2) // 2\n                        \n                        # 鼠标点击中心坐标\n                        pyautogui.click(center_x, center_y)\n                    found_copy = True\n\n                # 设置寻找poe_copy_success.png图片的超时时间为15秒\n                sleep(1)\n                found_success_image = False\n                timeout_success = time.time() + 5\n                while not found_success_image and time.time() < timeout_success:\n                    location, shape = find_image_on_screen(templates[\"success\"])\n                    if location:\n                        print(\"找到poe_copy_success图片，继续执行程序...\")\n                        found_success_image = True\n                    sleep(1)  # 每次检测间隔1秒\n\n                if not found_success_image:\n                    print(\"在15秒内未找到poe_copy_success图片，退出程序。\")\n                    webbrowser.open('file://' + os.path.realpath(txt_file_path), new=2)\n\n    # 设置目录路径\n    directory_path = '/Users/yanzhang/Documents/'\n\n    # 寻找目录下的第一个txt文件\n    for filename in os.listdir(directory_path):\n        if filename.endswith('.txt'):\n            txt_file_path = os.path.join(directory_path, filename)\n            break  # 找到第一个txt文件后停止循环\n\n    # 读取剪贴板内容\n    clipboard_content = get_clipboard_content()\n\n    # 检查clipboard_content是否为None或者是否是一个字符串\n    if clipboard_content:\n        # 使用splitlines()分割剪贴板内容为多行\n        lines = clipboard_content.splitlines()\n        # 移除空行\n        non_empty_lines = [line.replace('#', '').replace('*', '').strip() for line in lines if line.strip()]\n    else:\n        print(\"剪贴板中没有内容或pyperclip无法访问剪贴板。\")\n        non_empty_lines = []  # 确保non_empty_lines是一个列表，即使剪贴板为空\n\n    # 将非空行合并为一个字符串，用换行符分隔\n    modified_content = '\\n'.join(non_empty_lines)\n\n    # 读取/tmp/segment.txt文件内容\n    segment_file_path = '/tmp/segment.txt'\n    segment_content = \"\"\n    if os.path.exists(segment_file_path):\n        with open(segment_file_path, 'r', encoding='utf-8-sig') as segment_file:\n            segment_content = segment_file.read().strip()  # 使用strip()移除可能的空白字符\n\n    # 在segment_content后面添加一个换行符\n    segment_content += '\\n'\n    \n    # 将读取到的segment_content内容插入在剪贴板内容的最前面\n    final_content = segment_content + modified_content\n\n    # 追加处理后的内容到TXT文件\n    with open(txt_file_path, 'a', encoding='utf-8-sig') as txt_file:\n        txt_file.write(final_content)\n        txt_file.write('\\n\\n')  # 添加两个换行符以创建一个空行\n\n    # 使用函数\n    directory = \"/Users/yanzhang/Downloads/backup/TXT/Segments/\"\n    rename_first_segment_file(directory)\n\n    # 检查并删除/tmp/segment.txt文件\n    try:\n        if os.path.exists(segment_file_path):\n            os.remove(segment_file_path)\n    except Exception as e:\n        print(f\"无法删除文件：{e}\")\n\n    book_auto_signal_path = \"/private/tmp/book_auto_signal.txt\"\n    # 检查并删除/private/tmp/book_auto_signal.txt文件\n    if os.path.exists(book_auto_signal_path):\n        os.remove(book_auto_signal_path)\n\nif __name__ == '__main__':\n    main()"
            }
        ],
        "final_prompt": "fdsafdsafdsa"
    },
    {
        "id": "2025-05-25 23:45:33",
        "project_name": "fdsafds",
        "project_desc": "fdsafdsa",
        "files": [
            {
                "path": "/Users/yanzhang/Documents/python_code/Append_book.py",
                "filename": "Append_book.py",
                "content": "import os\nimport cv2\nimport time\nimport pyperclip\nimport pyautogui\nimport subprocess\nimport numpy as np\nfrom time import sleep\nfrom PIL import ImageGrab\nimport sys\nsys.path.append('/Users/yanzhang/Documents/python_code/Modules')\nfrom Rename_segment import rename_first_segment_file\n\ndef capture_screen():\n    # 使用PIL的ImageGrab直接截取屏幕\n    screenshot = ImageGrab.grab()\n    # 将截图对象转换为OpenCV格式\n    screenshot = cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)\n    return screenshot\n\n# 查找图片\ndef find_image_on_screen(template, threshold=0.9):\n    screen = capture_screen()\n    result = cv2.matchTemplate(screen, template, cv2.TM_CCOEFF_NORMED)\n    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\n    # 释放截图和模板图像以节省内存\n    del screen\n    if max_val >= threshold:\n        return max_loc, template.shape\n    else:\n        return None, None\n\ndef get_clipboard_content():\n    content = pyperclip.paste()\n    if not content:\n        return \"\"\n    \n    # 分割成行并去除空白行\n    lines = [line.strip() for line in content.splitlines() if line.strip()]\n    \n    # 如果行数小于3，直接返回原内容\n    if len(lines) < 3:\n        return \"\\n\".join(lines)\n    \n    # 移除第一行和最后一行\n    filtered_lines = lines[:-1]\n    \n    # 重新组合文本\n    return \"\\n\".join(filtered_lines)\n\ndef main():\n    # 定义模板路径字典\n    template_paths = {\n        \"kimi\": \"/Users/yanzhang/Documents/python_code/Resource/Kimi_copy.png\",\n        \"mistral\": \"/Users/yanzhang/Documents/python_code/Resource/Mistral_copy.png\",\n        \"thumb\": \"/Users/yanzhang/Documents/python_code/Resource/poe_thumb.png\",\n        \"success\": \"/Users/yanzhang/Documents/python_code/Resource/poe_copy_success.png\",\n        \"copy\": \"/Users/yanzhang/Documents/python_code/Resource/poe_copy.png\"\n    }\n\n    # 读取所有模板图片，并存储在字典中\n    templates = {}\n    for key, path in template_paths.items():\n        template = cv2.imread(path, cv2.IMREAD_COLOR)\n        if template is None:\n            raise FileNotFoundError(f\"模板图片未能正确读取于路径 {path}\")\n        templates[key] = template\n\n    pyautogui.click(x=1215, y=473)\n    sleep(0.5)\n    pyautogui.scroll(-80)\n    found_copy = False\n    while not found_copy:\n        location, shape = find_image_on_screen(templates[\"mistral\"])\n        if location:\n            print(\"找到copy图了，准备点击copy...\")\n            # 计算中心坐标\n            center_x = (location[0] + shape[1] // 2) // 2\n            center_y = (location[1] + shape[0] // 2) // 2\n            \n            # 鼠标点击中心坐标\n            pyautogui.click(center_x, center_y)\n            found_copy = True\n        else:\n            print(\"没找到图片，继续执行...\")\n            location, shape = find_image_on_screen(templates[\"kimi\"])\n            if location:\n                print(\"找到copy图了，准备点击copy...\")\n                # 计算中心坐标\n                center_x = (location[0] + shape[1] // 2) // 2\n                center_y = (location[1] + shape[0] // 2) // 2\n                \n                modify_x = center_x\n                modify_y = center_y - 2\n\n                # 鼠标点击中心坐标\n                pyautogui.click(modify_x, modify_y)\n                found_copy = True\n            else:\n                location, shape = find_image_on_screen(templates[\"thumb\"])\n                if location:\n                    print(\"找到copy图了，准备点击copy...\")\n                    # 计算中心坐标\n                    center_x = (location[0] + shape[1] // 2) // 2\n                    center_y = (location[1] + shape[0] // 2) // 2\n                    \n                    xCoord = center_x\n                    yCoord = center_y - 50\n\n                    # 使用pyautogui移动鼠标并进行右键点击\n                    pyautogui.moveTo(xCoord, yCoord)\n                    pyautogui.click(button='right')\n                    \n                    sleep(1)\n                    location, shape = find_image_on_screen(templates[\"copy\"])\n                    if location:\n                        # 计算中心坐标\n                        center_x = (location[0] + shape[1] // 2) // 2\n                        center_y = (location[1] + shape[0] // 2) // 2\n                        \n                        # 鼠标点击中心坐标\n                        pyautogui.click(center_x, center_y)\n                    found_copy = True\n\n                # 设置寻找poe_copy_success.png图片的超时时间为15秒\n                sleep(1)\n                found_success_image = False\n                timeout_success = time.time() + 5\n                while not found_success_image and time.time() < timeout_success:\n                    location, shape = find_image_on_screen(templates[\"success\"])\n                    if location:\n                        print(\"找到poe_copy_success图片，继续执行程序...\")\n                        found_success_image = True\n                    sleep(1)  # 每次检测间隔1秒\n\n                if not found_success_image:\n                    print(\"在15秒内未找到poe_copy_success图片，退出程序。\")\n                    webbrowser.open('file://' + os.path.realpath(txt_file_path), new=2)\n\n    # 设置目录路径\n    directory_path = '/Users/yanzhang/Documents/'\n\n    # 寻找目录下的第一个txt文件\n    for filename in os.listdir(directory_path):\n        if filename.endswith('.txt'):\n            txt_file_path = os.path.join(directory_path, filename)\n            break  # 找到第一个txt文件后停止循环\n\n    # 读取剪贴板内容\n    clipboard_content = get_clipboard_content()\n\n    # 检查clipboard_content是否为None或者是否是一个字符串\n    if clipboard_content:\n        # 使用splitlines()分割剪贴板内容为多行\n        lines = clipboard_content.splitlines()\n        # 移除空行\n        non_empty_lines = [line.replace('#', '').replace('*', '').strip() for line in lines if line.strip()]\n    else:\n        print(\"剪贴板中没有内容或pyperclip无法访问剪贴板。\")\n        non_empty_lines = []  # 确保non_empty_lines是一个列表，即使剪贴板为空\n\n    # 将非空行合并为一个字符串，用换行符分隔\n    modified_content = '\\n'.join(non_empty_lines)\n\n    # 读取/tmp/segment.txt文件内容\n    segment_file_path = '/tmp/segment.txt'\n    segment_content = \"\"\n    if os.path.exists(segment_file_path):\n        with open(segment_file_path, 'r', encoding='utf-8-sig') as segment_file:\n            segment_content = segment_file.read().strip()  # 使用strip()移除可能的空白字符\n\n    # 在segment_content后面添加一个换行符\n    segment_content += '\\n'\n    \n    # 将读取到的segment_content内容插入在剪贴板内容的最前面\n    final_content = segment_content + modified_content\n\n    # 追加处理后的内容到TXT文件\n    with open(txt_file_path, 'a', encoding='utf-8-sig') as txt_file:\n        txt_file.write(final_content)\n        txt_file.write('\\n\\n')  # 添加两个换行符以创建一个空行\n\n    # 使用函数\n    directory = \"/Users/yanzhang/Downloads/backup/TXT/Segments/\"\n    rename_first_segment_file(directory)\n\n    # 检查并删除/tmp/segment.txt文件\n    try:\n        if os.path.exists(segment_file_path):\n            os.remove(segment_file_path)\n    except Exception as e:\n        print(f\"无法删除文件：{e}\")\n\n    book_auto_signal_path = \"/private/tmp/book_auto_signal.txt\"\n    # 检查并删除/private/tmp/book_auto_signal.txt文件\n    if os.path.exists(book_auto_signal_path):\n        os.remove(book_auto_signal_path)\n\nif __name__ == '__main__':\n    main()"
            },
            {
                "path": "/Users/yanzhang/Documents/python_code/Click.py",
                "filename": "Click.py",
                "content": "import sys\nimport pyautogui\n\ndef main():\n    if len(sys.argv) != 3:\n        print(\"Usage: click.py <x> <y>\")\n        sys.exit(1)\n\n    x = int(sys.argv[1])\n    y = int(sys.argv[2])\n    pyautogui.click(x=x, y=y)\n\nif __name__ == \"__main__\":\n    main()"
            }
        ],
        "final_prompt": "fdsafdsafdsa"
    }
]